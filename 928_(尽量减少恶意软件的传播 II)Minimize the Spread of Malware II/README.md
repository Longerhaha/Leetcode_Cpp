# leetcode
# stick to it everyday and you will be a good algorithm engineer!
## 928_(尽量减少恶意软件的传播 II)Minimize the Spread of Malware II
## 问题描述、输入输出与样例

### 问题描述

在节点网络中，只有当 graph[i][j] = 1 时，每个节点 i 能够直接连接到另一个节点 j。

一些节点 initial 最初被恶意软件感染。只要两个节点直接连接，且其中至少一个节点受到恶意软件的感染，那么两个节点都将被恶意软件感染。这种恶意软件的传播将继续，直到没有更多的节点可以被这种方式感染。

假设 M(initial) 是在恶意软件停止传播之后，整个网络中感染恶意软件的最终节点数。

我们可以从初始列表中删除一个节点，并完全移除该节点以及从该节点到任何其他节点的任何连接。如果移除这一节点将最小化 M(initial)， 则返回该节点。如果有多个节点满足条件，就返回索引最小的节点。

__提示__：

1. 1 < graph.length = graph[0].length <= 300
2. 0 <= graph[i][j] == graph[j][i] <= 1
3. graph[i][i] = 1
4. 1 <= initial.length < graph.length
5. 0 <= initial[i] < graph.length

### 函数输入与输出

* 输入：
	* vector<vector<int>>& graph：节点网络的连接关系图
	* vector<int>& initial：被恶意软件感染的列表
* 输出：
	* int：整个网络中感染恶意软件的最终节点数 M 最小的感染节点
	
### 问题样例

#### 示例1

输出：graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]

输入：0：
	
#### 示例2

输入：graph = [[1,1,0],[1,1,1],[0,1,1]], initial = [0,1]

输出：1

#### 示例3
	
## 思路描述与代码	
### 思路描述（DFS）
min_M 记录最小的 M
遍历所有感染节点 initial[i]：
1. 去除节点 initial[i] 与其他节点之间的连接
2. 记录除感染节点 initial[i] 外的感染表
3. DFS求去除节点 initial[i] 后的整个网络中感染恶意软件的最终节点数 M
4. 比较 M 与 min_M

### 代码
```cpp
void DFS(vector<vector<int>>& Graph, vector<bool>& visit, vector<bool>& infection, int node, int& M){
	for( int i = 0; i < Graph.size(); i++ ){
		//cout << Graph[node][i] << endl;
		if(Graph[node][i] && !visit[i]) {
			infection[i] = true;
			M++;
			visit[i] = true;
			DFS(Graph, visit, infection, i, M);
		}
	}
	
}

int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
	int initial_len = initial.size();
	int graph_node_size = graph.size();
	if(initial_len == 1) return initial[0];
	//初始化最小的 M
	int min_M = graph_node_size;
	int min_M_initial_idx = -1;
	for( int i = 0; i < initial_len; i++ ){
		vector<bool> visit(graph_node_size, false);
		vector<bool> infection(graph_node_size, false);
		vector<vector<int>> Graph(graph);
		for( int j = 0; j < graph_node_size; j++ ){
			//去除节点 initial[i] 与其他节点之间的连接
			if(Graph[initial[i]][j]){
				Graph[initial[i]][j] = false;
				Graph[j][initial[i]] = false;
			}
		}
		for( int j = 0; j < initial_len; j++ ){
			if(j != i) infection[initial[j]] = true;
		}
		
		int M = 0;
		for( int j = 0; j < initial_len; j++ ){
			if(j != i && !visit[initial[j]]){
				M++;
				visit[initial[j]] = true;
				DFS(Graph, visit, infection, initial[j], M);
			}
		}
		//cout << i << " " << M << endl;
		if(min_M > M) min_M = M, min_M_initial_idx = i;
		else if(min_M == M) min_M_initial_idx = initial[min_M_initial_idx] > initial[i] ? i : min_M_initial_idx;
	}
	return initial[min_M_initial_idx];
}
```
## 思考与拓展
### 思考
本题码量还是有的，主要在于做DFS。时间运行了100ms，等到图表做好后再比较下效率。
### 拓展
暂无想法。


	  
# 希望我能在这一年坚持下来，每天都不放弃，每天都至少刷一道题，我相信我可以的！
