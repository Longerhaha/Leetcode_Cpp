# leetcode
# stick to it everyday and you will be a good algorithm engineer!
## 150_(逆波兰表达式求值)Evaluate Reverse Polish Notation
## 问题描述、样例与输入输出

### 问题描述

根据逆波兰表示法，求表达式的值。

有效的运算符包括 +, -, *, / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。

__说明__：

1. 整数除法只保留整数部分。
2. 给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。 

### 问题样例

	示例1:
	输入: 
	["2", "1", "+", "3", "*"]
	输出: 
	9
	解释：
	((2 + 1) * 3) = 9
	
	示例2:
	输入: 
	["4", "13", "5", "/", "+"]
	输出: 
	6
	解释: 
	(4 + (13 / 5)) = 6
	
	
	示例3:
	输入: 
	["10", "6", "9", "3", "+", "-11", "*", "/", "*", "17", "+", "5", "+"]
	输出: 
	22
	解释：
	  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5
	= ((10 * (6 / (12 * -11))) + 17) + 5
	= ((10 * (6 / -132)) + 17) + 5
	= ((10 * 0) + 17) + 5
	= (0 + 17) + 5
	= 17 + 5
	= 22

### 函数输入与输出

* 输入：
	* vector<string>& tokens: 给定逆波兰表达式的字符串列表
* 输出：
	* int：逆波兰表达式求值的结果

## 思路	
### 堆栈法

	int evalRPN(vector<string>& tokens) {
        stack<int> s;
        for(auto x : tokens){
            //不是运算符号
            if(x != "+" && x != "-" && x != "*" && x != "/"){
                s.push(stoi(x));
            }
            else{
                //从堆栈取两个出来做运算，并把结果压入堆栈
                int opt2 = s.top();
                s.pop();
                int opt1 = s.top();
                s.pop();
                
                if(x == "+"){
                    s.push(opt1 + opt2);
                }
                else if(x == "-"){
                    s.push(opt1 - opt2);
                }
                else if(x == "*"){
                    s.push(opt1 * opt2);
                }
                else{
                    s.push(opt1 / opt2);
                }
                    
            }
        }
        return s.top();
    }
		

 
## 拓展与思考：
### 拓展
暂无。
### 思考
本题较为基础，一个堆栈即可搞定。
	  
# 希望我能在这一年坚持下来，每天都不放弃，每天都至少刷一道题，我相信我可以的！
