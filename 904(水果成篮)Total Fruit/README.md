# leetcode
# stick to it everyday and you will be a good algorithm engineer!
## 904(水果成篮)Total Fruit
## 问题描述、输入输出与样例

### 问题描述
在一排树中，第 i 棵树产生 tree[i] 型的水果。
你可以从你选择的__任何树__开始，然后重复执行以下步骤：

1. 把这棵树上的水果放进你的篮子里。如果你做不到，就停下来。
2. 移动到当前树右侧的下一棵树。如果右边没有树，就停下来。

请注意，在选择一颗树后，你没有任何选择：你必须执行步骤 1，然后执行步骤 2，然后返回步骤 1，然后执行步骤 2，
依此类推，直至停止。

你有两个篮子，每个篮子可以携带任何数量的水果，但你希望每个篮子只携带一种类型的水果。
用这个程序你能收集的水果总量是多少？

### 函数输入与输出

* 输入：
	* vector<int>& tree：树产生类型的水果的一维数据的引用
* 输出：
	* int：你能收集的水果总量
	
### 问题样例

	示例1:
	输入：[1,2,1]
	输出：3
	解释：我们可以收集 [1,2,1]。
	
	示例2:
	输入：[0,1,2,2]
	输出：3
	解释：我们可以收集 [1,2,2].
	如果我们从第一棵树开始，我们将只能收集到 [0, 1]。
	
	示例3:
	输入：[1,2,3,2,2]
	输出：4
	解释：我们可以收集 [2,3,2,2].
	如果我们从第一棵树开始，我们将只能收集到 [1, 2]。
	
	示例4:
	输入：[3,3,3,1,2,1,1,2,3,3,4]
	输出：5
	解释：我们可以收集 [1,2,1,1,2].
	如果我们从第一棵树或第八棵树开始，我们将只能收集到 4 个水果。
	
	提示：
	1. 1 <= tree.length <= 40000
	2. 0 <= tree[i] < tree.length
	
	
## 思路描述与代码	
### 思路描述（结合滑窗的动态规划方法）

	滑窗：pre是个长度为2的滑窗，记录最靠近当前位置i的两种类型水果的序号，pre[1]最靠近，其次pre[0]
	
	dp[i]：代表以i为结束位置的采集方法能收集到的水果
	
	dp[i] = 当前类型水果与最接近的类型水果所能收集到的水果的数目， 最接近的两种类型水果都不一样
	      = dp[i - 1] + 1，与最接近的两种类型水果至少有一种相同
	
### 代码
	
	int totalFruit(vector<int>& tree) {
        int len = tree.size();
        //pre是个长度为2的滑窗，记录最靠近当前位置的两种类型水果的序号
        vector<int> pre(2, -1);
        //dp[i]代表以i为结束位置的采集方法能收集到的水果
        vector<int> dp(len, 0);
        int max_collect = 0;
        for( int i = 0; i < len; i++ ){
            //如果与最接近的两种类型水果都不一样则需要判断能收集到多少水果
            if(tree[i] != pre[0] && tree[i] != pre[1]){
                int search = i - 1;
                //求最接近的类型的水果的连续个数
                while(search >= 0 && (tree[search] == pre[1] || tree[search] == tree[i])) search--;
                //与最接近的类型的水果组合在一起能收集的水果
                dp[i] = i - search;
                //滑动窗口
                pre[0] = pre[1];
                pre[1] = tree[i];
            }
            else{
                //更新为最新的滑窗窗口
                //比如 1 6 5 6 6 这种
                //最新的应该是6而不是5
                if(tree[i] != pre[1]){
                    swap(pre[0], pre[1]);
                }
                //直接在前一个的基础上加1即可
                dp[i] = dp[i - 1] + 1;
            }
            //cout << dp[i] << ":" << pre[0] << " " << pre[1] << endl;
            if(dp[i] > max_collect) max_collect = dp[i];
        }
        return max_collect;
    }
 
 
## 拓展与思考：
### 拓展
如果你有x（x >= 3）个篮子呢？
### 思考
本题的关键是滑窗的更新，本题的解法也易扩展到多个篮子的情况。
	  
# 希望我能在这一年坚持下来，每天都不放弃，每天都至少刷一道题，我相信我可以的！
