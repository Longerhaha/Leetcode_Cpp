# leetcode
# stick to it everyday and you will be a good algorithm engineer!
## 905_(按奇偶校验排序数组)Sort Array by Parity
## 问题描述、样例与输入输出

### 问题描述

给定一个非负整数数组 A，返回一个由 A 的所有偶数元素组成的数组，后面跟 A 的所有奇数元素。

你可以返回满足此条件的任何数组作为答案。

### 函数输入与输出

* 输入：
	* vector<int>& A：非负整数数组 A 的引用
* 输出：
	* vector<int>：奇偶校验排序后的数组
	
### 问题样例

	示例1:
	输入: 
	[3,1,2,4]
	  
	输出: 
	[2,4,3,1]
	注：输出 [4,2,3,1]，[2,4,1,3] 和 [4,2,1,3] 也会被接受。
	
	
## 思路描述与代码	
### 思路描述

	首先分析题目，题目输出要求相对宽松，所以方法有很多种。如果不是原地修改，则我觉得这道题就毫无难度了。
	
	我采取的是原地修改的思路。记录当前遍历的所有的数据(data[0] ... data[i])的第一个奇数的位置，如果当前的
数是偶数，则与第一个奇数交换数据，同时下一个奇数的位置为当前奇数的位置加1。

	下一个奇数的位置为当前奇数的位置加1是因为之前遍历的数据已经是奇偶校验排序数组，所以当前第一个奇数的位置
的下一个必然还是奇数（如果奇数大于两个的话），当然有可能当前的数据都是偶数或者只有一个奇数，代码中也对此进
行了考虑，使其兼容这两种情况。

### 代码

    //原地修改
    // odd_begin 记录已重排的数据的第一个奇数的位置
    vector<int> sortArrayByParity(vector<int>& A) {
        int odd_begin = -1;
        for( int i = 0; i < A.size(); i++ ){
            //第一个奇数的位置
            if(odd_begin == -1 && A[i] % 2 == 1){
                odd_begin = i;
            }
            //如果是偶数，则与第一个奇数的位置的数据交换， odd_begin 指向下一个奇数的位置
			//如果之前都是偶数，则 odd_begin 维持-1，不会进入该if
			//如果之前只有一个奇数，则交换数据，odd_begin + 1的位置恰好是交换后的数据的第一个奇数的位置
            else if(odd_begin != -1 && A[i] % 2 == 0){
                swap(A[odd_begin], A[i]);
                odd_begin++;
            }
        }
        return A;
    }

 
## 拓展与思考：
### 拓展
如果给你的数据是链表呢？道理是一样的。
### 思考
本题，考察的内容应该是如何原地修改。
	  
# 希望我能在这一年坚持下来，每天都不放弃，每天都至少刷一道题，我相信我可以的！
