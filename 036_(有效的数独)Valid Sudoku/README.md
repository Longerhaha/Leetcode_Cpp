# leetcode
# stick to it everyday and you will be a good algorithm engineer!
## 036_(有效的数独)Valid Sudoku
## 问题描述、输入输出与样例

### 问题描述

判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。

1. 数字 1-9 在每一行只能出现一次。
2. 数字 1-9 在每一列只能出现一次。
3. 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。

数独部分空格内已填入了数字，空白格用 '.' 表示。

数独例子可以参见[36题 有效的数独](https://leetcode-cn.com/problems/valid-sudoku/)

__说明__:
1. 一个有效的数独（部分已被填充）不一定是可解的。
2. 只需要根据以上规则，验证已经填入的数字是否有效即可。
3. 给定数独序列只包含数字 1-9 和字符 '.' 。
4. 给定数独永远是 9x9 形式的。

### 函数输入与输出

* 输入：
	* vector<vector<char>>& board：数组的二维矩阵 board
* 输出：
	* bool：是否是有效的数独
	
### 问题样例

#### 示例1

输入: 

	[
	  ["8","3",".",".","7",".",".",".","."],
	  ["6",".",".","1","9","5",".",".","."],
	  [".","9","8",".",".",".",".","6","."],
	  ["8",".",".",".","6",".",".",".","3"],
	  ["4",".",".","8",".","3",".",".","1"],
	  ["7",".",".",".","2",".",".",".","6"],
	  [".","6",".",".",".",".","2","8","."],
	  [".",".",".","4","1","9",".",".","5"],
	  [".",".",".",".","8",".",".","7","9"]
	]

输出: false

解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。
	
## 思路描述与代码	
### 思路描述（标记法）
使用 validMat[3][9][9]标记数独元素是否存在，初始化为不存在。

validMat[0][idx1][idx2]代表第 idx1 行的 字符 idx2 + 1已经存在

validMat[1][idx1][idx2]代表第 idx1 列的 字符 idx2 + 1已经存在

validMat[2][idx1][idx2]代表第 idx1 块的 字符 idx2 + 1已经存在

块的标记方式为 ：

	0 1 2
	3 4 5
	6 7 8

然后遍历搜索
```cpp
for( int i = 0; i < 9; i++ ){
	for( int j = 0; j < 9; j++ ){
		if(遇见 ".") 则结束当前循环;
		if(board[i][j] 不在 i 行、 j 列、 i/3 * 3 + j / 3 个块中){
			在 i 行、 j 列、 i/3 * 3 + j / 3 个块中
		}
		else 返回false，即是无效的数独;
	}
}
返回 true，即是有效的数独;
```

### 代码
```cpp
bool isValidSudoku(vector<vector<char>>& board) {
	bool validMat[3][9][9];
	
	for( int i = 0; i < 3; i++ ){
		for( int j = 0; j < 9; j++ ){
			for( int k = 0; k < 9; k++ ){
				validMat[i][j][k] = false;
			}
		}
	}
	
	for( int i = 0; i < 9; i++ ){
		for( int j = 0; j < 9; j++ ){
			//跳过'.'
			if(board[i][j] == '.') continue;
			if(!validMat[0][i][(int)(board[i][j] - '1')] && !validMat[1][j][(int)(board[i][j] - '1')] && !validMat[2][i/3 * 3 + j / 3][(int)(board[i][j] - '1')]) {
				validMat[0][i][(int)(board[i][j] - '1')] = true;
				validMat[1][j][(int)(board[i][j] - '1')] = true;
				validMat[2][i/3 * 3 + j / 3][(int)(board[i][j] - '1')] = true;
			}
			else return false;
		}
	}
	return true;
}
```
## 思考与拓展
### 思考
标记法的思想其实和哈希表差不多，但标记法与哈希表法空间复杂度更优。
### 拓展
如果让你把数独解出来呢？
  
# 希望我能在这一年坚持下来，每天都不放弃，每天都至少刷一道题，我相信我可以的！
