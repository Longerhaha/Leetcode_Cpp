# LeetCode
# Stick to practice coding of algorithmic problems everyday and you would be a good algorithm engineer someday!
## 073_(矩阵置0)Set Matrix Zeros
## 1 问题描述、输入输出与样例
### 1.1 问题描述
给定一个 m x n 的矩阵，如果一个元素为 0，则将其所在行和列的所有元素都设为 0。请使用__原地__算法。
__进阶__：
* 一个直接的解决方案是使用  O(mn) 的额外空间，但这并不是一个好的解决方案。
* 一个简单的改进方案是使用 O(m + n) 的额外空间，但这仍然不是最好的解决方案。
* 你能想出一个常数空间的解决方案吗？
### 1.2 输入与输出
输入：
* vector<vector<int>>& matrix:给定的矩阵

输出：
* void:原地修改
### 1.3 样例
#### 1.3.1 样例1
输入:<br> 
[<br>
　[1,1,1],<br>
　[1,0,1],<br>
　[1,1,1]<br>
]<br>
输出:<br> 
[<br>
　[1,0,1],<br>
　[0,0,0],<br>
　[1,0,1]<br>
]<br>
#### 1.3.2 样例2
输入: <br>
[<br>
　[0,1,2,0],<br>
　[3,4,5,2],<br>
　[1,3,1,5]<br>
]<br>
输出:<br> 
[<br>
　[0,0,0,0],<br>
　[0,4,5,0],<br>
　[0,3,1,0]<br>
]<br>
## 2 思路描述与代码	
### 2.1 思路描述（常数空间法）
利用第一行和第一列记录除第一行和第一列的 0 元素所在的行列位置 matrix[0][x] 为 0 则表明第 x 列有 0，matrix[x][0] 为 0 则表明第 x 行有 0<br>
row0 初始化为-1，记录第一列是否有 0 元素，遍历后大于等于0表明第一列有零<br>
col0 初始化为-1，记录第一行是否有 0 元素，遍历后大于等于0表明第一行有零<br>
遍历第一次把需要记录的记录下来<br>
遍历第二次把含 0 的行和列的其他元素置0<br>
最后再对第一行和第一列进行是否含 0 的检查，若有则置 0 <br> 

比如输入: <br>
[<br>
　[0,1,2,0],<br>
　[3,4,5,2],<br>
　[1,3,1,5]<br>
]<br>
第一次遍历后 row0 = 0, col0 = 3, matrix 为<br>
[<br>
　[0,1,2,0],<br>
　[3,4,5,2],<br>
　[1,3,1,5]<br>
]<br>
然后再置 0 第一列和第一行，matrix 为<br>
[<br>
　[0,1,2,0],<br>
　[0,4,5,0],<br>
　[0,3,1,0]<br>
]<br>
然后由于 row0 = 0, col0 = 3，都是非 -1，所以第一行、第一列置0，matrix 为<br>
[<br>
　[0,0,0,0],<br>
　[0,4,5,0],<br>
　[0,3,1,0]<br>
]<br>
### 2.2 代码
```cpp
void setZeroes(vector<vector<int>>& matrix) {
    int m = matrix.size();
    int n = matrix[0].size();
    //row0 初始化为-1，记录第一列是否有 0 元素，遍历后大于等于0表明第一列有零
    //col0 初始化为-1，记录第一行是否有 0 元素，遍历后大于等于0表明第一行有零
    int row0 = -1, col0 = -1;
    for( int i = 0; i < m; i++ ){
        if(matrix[i][0] == 0) row0 = i;
        for( int j = 0; j < n; j++ ){
            if(i == 0 && matrix[i][j] == 0) col0 = j;
            if(matrix[i][j] == 0){
                matrix[0][j] = 0;
                matrix[i][0] = 0;
            }
        }
    }
   
    //根据第一行、第一列记录的结果置 0 其所在的行与列的其他元素
    for( int i = 1; i < m; i++ ){
        for( int j = 1; j < n; j++ ){
            if(matrix[i][0] == 0 || matrix[0][j] == 0) matrix[i][j] = 0;
        }
    }
    //校正第一列
    if(row0 != -1){
        for( int i = 0; i < m; i++) matrix[i][0] = 0;
    }
    //校正第一行
    if(col0 != -1){
        for( int j = 0; j < n; j++) matrix[0][j] = 0;
    }
}
```
## 3 思考与拓展
### 3.1 思考
#### 3.1.1 其他方法
#### 3.1.1.1 O(m + n) 的额外空间法
利用 row[m] 记录 0 所在的行, col[n] 记录 0 所在的列<br>
第一遍遍历记录<br>
第二遍遍历置0即可<br>

#### 3.1.2 复杂度分析
方法|空间复杂度|时间复杂度
--- | --- | ---
常数空间法|O(1)|O(mn)
O(m + n) 的额外空间法|O(m + n)|O(mn)
#### 3.1.3 难点分析
1. 增加判断第一行和第一列是否有0的表示方法
### 3.2 拓展
常数空间法其实就是O(m + n) 的额外空间法的改法，充分利用置0的规则去简化空间复杂度。

	  
## 我一定要在这一年每天至少刷一道题，坚持不懈，持之以恒，我一定行！
