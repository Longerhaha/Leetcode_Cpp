# leetcode
# stick to it everyday and you will be a good algorithm engineer!
## 908_(最小差值 I)Smallest Range I
## 问题描述、输入输出与样例

### 问题描述

给定一个整数数组 A，对于每个整数 A[i]，我们可以选择任意 x 满足 -K <= x <= K，并将 x 加到 A[i] 中。

在此过程之后，我们得到一些数组 B。

返回 B 的最大值和 B 的最小值之间可能存在的最小差值。

### 函数输入与输出

* 输入：
	* vector<int>& A：给定的整数数组A
	* int K：可以选定加上的值的范围 -K <= x <= K
* 输出：
	* int：最小差值
	
### 问题样例

#### 示例1
	
	输入: 
	A = [1], K = 0
	输出: 
	0
	解释：
	B = [1]

#### 示例2

	输入: 
	A = [0,10], K = 2
	输出: 
	0
	解释：
	B = [2,8]
	
#### 示例3

	输入: 
	A = [1,3,6], K = 3
	输出: 
	0
	解释：
	B = [3,3,3] 或 B = [4,4,4]
	

	
## 思路描述与代码	
### 思路描述（常规方法）
这里主要分为两种情况：
1. 最大值与最小值的差小于等于 2 * K，在这种情况下我们可以加加减减使所有的数都一样，比如全部调整为最大值与最小值的和的二分之一，于是输出为0。
2. 最大值与最小值的差大于 2 * K，在这种情况下最小值必须要去加 K ，最大值必须要去减 K 才能缩小差距，其他的数肯定可以控制在[最小值 + K, 最大值 + K]，于是返回
最大值 - 最小值 - 2 * K。

### 代码

	int smallestRangeI(vector<int>& A, int K) {
        int len = A.size();
        sort(A.begin(), A.end());
        if(A[len - 1] - A[0] <= 2 * K) return 0;
        else return A[len - 1] - A[0] - 2 * K;
    }
 
## 拓展与思考：
### 拓展
如果只能让你加 K 或者减 K 呢？
### 思考
本题较为简单，我没有想到这种最简单的方法而是自己去设定个目标去遍历，然后更新值后的最小值与最大值。本文提到的常规方法相对较为简便。
	  
# 希望我能在这一年坚持下来，每天都不放弃，每天都至少刷一道题，我相信我可以的！
